---
layout: post
title:  "맵리듀스 작동 방법"
date:   2019-04-16 00:40:21
categories: [DataScience]
comments: true
---


# 맵리듀스 작동 방법
## 맵리듀스 잡 실행 상세분석 

#### 맵리듀스 잡의 전체 과정
* job 객체의 submit() 메서드 호출로 맵리듀스 잡 실행 가능 (그림의 1번 과정) 
![image](https://user-images.githubusercontent.com/28076434/56142959-904d3900-5fda-11e9-8acc-007fbc29e789.png)

* 다섯 개의 독립적인 단계
1. 클라이언트 
-맵리듀스 잡을 제출
2. YARN 리소스 매니저 
-클러스터 상에 계산 리소스의 할당을 제어함
3. YARN 노드 매니저 
-클러스터의 각 머신에서 계산 컨테이너를 시작하고 모니터링함
4. 맵리듀스 애플리케이션 마스터 
-맵리듀스 잡을 수행하는 각 태스크를 제어함
-애플리케이션 마스터와 맵리듀스 태스크는 컨테이너 내에서 실행됨
-리소스 매니저는 잡을 할당하고 노드 매니저는 태스크를 관리함  
5. 분산 파일 시스템
-다른 단계 간에 잡 리소스 파일들을 공유함 (보통 HDFS 사용)


#### 잡 제출
* submit() 메서드는 내부의 JobSubmitter 인스턴스를 생성
* submitJobInternal() 메서드를 호출
* JobSubmitter의 잡 제출 과정
1. 리소스 매니저에 맵리듀스 잡 ID로 사용될 새로운 애플리케이션 ID를 요청
2. 잡의 출력 명세 확인(출력 디렉터리가 지정되지 않았거나 이미 존재한다면 해당 잡은 제출되지 않고 MR프로그램에 에러를 전달함)
3. 잡의 입력 스플릿을 계산(스플릿을 계산할 수 없다면 MR프로그램에 에러를 전달함)
4. 잡 실행에 필요한 잡 JAR파일, 환경 설정 파일, 계산된 입력 스플릿 등의 잡 리소스를 HDFS와 같은 공유 파일 시스템에 있는 해당 잡 ID 이름의 디렉터리에 복사함
5. 리소스 매니저의 submitApplication()을 호출하여 잡을 
* 일단 잡을 제출하면 waitForCompletion() 메서드가 1초에 한 번씩 잡의 진행상황을 조사, 변경 내역은 콘솔로 보여줌
* 잡이 성공적으로 완료되면 잡 카운터를 보여줌

#### 잡 초기화
1. 리소스 매니저가 submitApplication() 메서드의 호출을 받으면 YARN 스케줄러에 요청을 전달함
2. 스케줄러는 컨테이너를 하나 할당하고, 리소스 매니저는 노드 매니저의 운영 규칙에 따라 애플리케이션 마스터 프로세스를 시작함
##### <애플리케이션 마스터>
* 자바 애플리케이션이며 메인 클래스는 MRAppMaster
* 잡을 초기화할 때 잡의 진행 상태를 추적하기 위한 다수의 북키핑 객체를 생성 후, 이후 각 태스크로부터 진행 및 종료 보고서를 받음
* 클라이언트가 계산한 입력 스플릿 정보를 공유 파일시스템에서 읽어옴
* 입력 스플릿 별로 맵 태스크 객체를 생성하고 mapreduce.job.reduces 속성의 값(리듀서 수)만큼 객체를 생성하여 각 태스크는 ID를 부여받음
* 잡을 구성하는 태스크를 실행하는 방법을 결정해야 함
-잡의 크기가 작다면 자신의 JVM에서 실행할 수도 있음. 이러한 잡을 우버태스크로 실행된다고 함 
-우버 태스크 : 애플리케이션 마스터 내의 맵리듀스에서 실행되는 것으로 별도의 컨테이너를 생성하지 않아 오버헤드를 줄일 수 있음 
-작은 잡이란 보통 10개 미만의 매퍼와 하나의 리듀서, HDFS 블록 하나보다 작은 크기의 입력을 말함 
-우버 태스크는 반드시 mapreduce.job.ubertask.enable속성을 true로 변경하여 활성화해야 함
* 태스크를 실행하기 전 OutputCommitter의 setupJob() 메서드를 호출하여 잡의 최종 출력 디렉터리와 태스크 출력을 위한 임시 작업 공간을 생성함

#### 태스크 할당
1. 잡을 우버 태스크로 실행하기 적합하지 않다면 애플리케이션 마스터는 리소스 매니저에 잡의 모든 맵과 리듀스 태스크를 위한 컨테이너를 요청함(우선 순위 : 맵 태스크 > 리듀스 태스크)
2. 리듀스 태스크는 클러스터의 어느 곳에서도 실행 가능하지만 맵 태스크 요청은 데이터 지역성 제약이 있음
3. 맵 태스크는 각 태스크 트래커와 인접한 입력 스플릿을 갖도록 태스크가 할당됨
* 최적화 정도 : 태스크와 입력 스플릿이 동일 노드에 존재할 때(데이터 로컬) > 동일 랙에 존재할 때(렉 로컬) > 태스크가 다른 노드에서 입력 스플릿을 조회할 때
4. 요청할 때 태스크를 위한 메모리 요구사항과 CPU 수를 명시함(기본적으로 1024MB의 메모리와 가상 코어 1개를 각 맵과 리듀스 태스크에 할당)

#### 태스크 실행
1. 리소스 매니저의 스케줄러가 특정 노드 상의 컨테이너를 위한 리소스를 태스크에 할당하면 애플리케이션 마스터는 노드 매니저와 통신하며 컨테이너를 시작함
2. 각 태스크는 YarnChild 메인 클래스를 가진 자바 애플리케이션으로 실행됨
3. 공유파일시스템에 저장되어 있는 잡 환경 설정, Jar파일, 분산 캐시와 관련된 파일 등의 리소스를 로컬로 가져와야 함
4. 최종적으로 맵과 리듀스 태스크를 실제 실행함
* YarnChild는 전용 JVM에서 실행되므로 사용자 정의 맵과 리듀스 함수에서 버그가 발생하여 강제 종료 혹은 멈추어도 노드 매니저는 영향을 받지 않음
* 각 태스크는 태스크 자체외 동일한 JVM에서 설정과 커밋 동작을 수행, 잡의 OutputCommitter가 이를 결정함
* 파일 기반의 잡에서 커밋 동작은 임시 위치에서 최종 위치로 태스크 출력을 옮김
* 커밋 프로토콜은 투기적 실행히 활성화되었을 때 중복 태스크 중 단 하나만 커밋하고 나머지는 버림(뒤에 등장)

##### <스트리밍 또는 파이프>
![image](https://user-images.githubusercontent.com/28076434/56226242-cc050300-60ad-11e9-9021-09ee9e820de8.png)
* 스트리밍은 사용자가 제공한 실행파일을 시작하고 이와 통신하기 위한 목적을 가진 특별한 맵과 리듀스 태스크를 실행함
* 표준 입출력 스트림을 통해 프로세스와 통신함
1. 자바 프로세스는 키-값 쌍을 외부 프로세스에 전달
2. 사용자 정의 맵과 리듀스 함수로 처리
3. 출력 키-값 쌍을 자바 프로세스에 돌려줌
-> 노드 매니저 관점에서는 자식 프로세스가 맵과 리듀스 코드를 스스로 실행한 것처럼 보임

#### 진행 상황과 상태 갱신
![image](https://user-images.githubusercontent.com/28076434/56228213-38820100-60b2-11e9-9ceb-8b08b1982094.png)
* 맵리듀스 잡은 수행 시간이 오래걸리는 배치 잡이므로 사용자가 잡의 진행 상황에 대한 피드백을 받는 것이 매우 중요함
* 잡과 태스크는 실행중, 완료됨, 실패와 같은 상태, 맵과 리듀스의 진행상황, 명세 등의 상태 정보를 가짐
* 태스크가 수행되는 동안 태스크는 자신의 진행 상황을 추적함
-맵 태스크 : 처리한 입력 데이터의 비율
-리듀스 태스크 : 리듀스가 처리한 입력 데이터의 비율
* 전체 진행 과정을 총 세 부분으로 나눔(셔플의 세 단계와 관련있음)
-책 예시 : 리듀서에서 입력의 절반을 처리한 경우, 진행 상황은 5/6 (복사와 정렬이 각각 1/3, 리듀스의 절반 1/6 진행)
* 맵리듀스가 진행 중임을 판단하는 동작
하둡은 진행 중인 태스크는 실패로 보지 않음. 따라서 진행상황을 보고하는 것이 매우 중요함.
1. 입력 레코드 읽기(매퍼 또는 리듀서에서)
2. 출력 레코드 쓰기(매퍼 또는 리듀서에서)
3. 상태 명세의 설정(Reporter 또는 TaskAttemptContext의 setStatus() 메서드를 통해)
4. 카운터 증가(Reporter의 incrCounter() 메서드 또는 Counter의 increment() 메서드를 사용하여)
5. Reporter 또는 TaskAttempContext의 progress() 메서드 호출

* 태스크는 수행 중 발생하는 다양한 이벤트를 세는 여러 카운터를 가짐
* 맵과 리듀스 태스크가 실행되면서 자식 프로세스는 부모인 애플리케이션 마스터와 밀접한 인터페이스를 통해 통신함
-태스크는 진행상황과 상태 정보(카운터 포함)를 집계하여 매 3초마다 인터페이스를 통해 애플리케이션 마스터에 보고함
* 리소스 매니저 웹 UI는 실행 중인 모든 애플리케이션 각각의 애플리케이션 마스터 웹 UI 링크를 보여줌
* 잡이 진행되는 동안 클라이언트는 매초마다 애플리케이션 마스터를 폴링하여 가장 최근의 상태를 받으며 Job의 getStatus() 메서드를 이용해 JobStatus 인스턴스(잡의 모든 상태 정보)를 얻을 수 있음

#### 잡 완료
1. 애플리케이션 마스터가 마지막 태스크가 완료되었다는 통지를 발ㄷ으면 잡의 상태를 성공으로 변경
2. 사용자에게 통지할 메시지를 출력함
3. waitForCompletion() 메서드가 반환되며 잡 통계와 카운터가 콘솔에 출력됨
* HTTP 잡 통지를 보내도록 설정되어 있다면 애플리케이션 마스터는 이를 수행함
4. 잡이 완료되면 애플리케이션 마스터와 태스크 컨테이너는 작업 상태를 정리하고 OutputCommitter의 commitJob() 메서드를 호출함

## 실패
실제 환경에서는 사용자 코드의 버그 때문에 프로세스가 강제로 죽거나 서버에 장애가 발생하는 일이 빈번함

#### 
